import { headers } from 'next/headers'
import { stripe } from '@/lib/stripe'
import Stripe from 'stripe'
import Player from '@/db/models/player.model'
import { pricingTable } from '@/config/pricing'
import { connectMongooseToDatabase } from '@/db'

/**
 * API Route: POST /api/webhook/stripe
 *
 * Webhook Stripe pour g√©rer les √©v√©nements de paiement.
 *
 * @remarks
 * Cette route est appel√©e automatiquement par Stripe lorsqu'un √©v√©nement se produit
 * (paiement r√©ussi, √©chec, remboursement, etc.).
 *
 * Architecture:
 * - Layer: Infrastructure (API)
 * - D√©pendances: stripe (webhook verification), Wallet (persistence)
 *
 * IMPORTANT:
 * - Cette route doit √™tre configur√©e dans le Dashboard Stripe
 * - URL du webhook: https://your-domain.com/api/webhook/stripe
 * - Secret du webhook: STRIPE_WEBHOOK_SECRET (env variable)
 *
 * S√©curit√©:
 * - V√©rifie la signature du webhook pour garantir l'authenticit√©
 * - Utilise le payload brut (raw body) requis par Stripe
 *
 * Flow:
 * 1. R√©cup√©ration de la signature Stripe
 * 2. Validation du payload avec constructEvent
 * 3. Traitement selon le type d'√©v√©nement
 * 4. Mise √† jour du wallet de l'utilisateur
 *
 * @example
 * Configuration Stripe CLI pour tester localement:
 * ```bash
 * stripe listen --forward-to localhost:3000/api/webhook/stripe
 * stripe trigger checkout.session.completed
 * ```
 *
 * @param req - Request avec le payload Stripe
 * @returns Response 200 si succ√®s, 400 si erreur
 */

// Force l'utilisation du runtime Node.js (requis pour Stripe webhooks)
export const runtime = 'nodejs'

export async function POST (req: Request): Promise<Response> {
  // R√©cup√©ration de la signature Stripe depuis les headers
  const sig = (await headers()).get('stripe-signature')

  // Lecture du payload brut (requis par Stripe)
  const payload = await req.text()

  let event: Stripe.Event

  try {
    // V√©rification de la signature et construction de l'√©v√©nement
    event = stripe.webhooks.constructEvent(
      payload,
      sig as string,
      process.env.STRIPE_WEBHOOK_SECRET as string
    )
  } catch (err: any) {
    console.error('‚ö†Ô∏è Webhook signature verification failed:', err.message)
    return new Response(`Webhook Error: ${err.message as string}`, {
      status: 400
    })
  }

  // Traitement selon le type d'√©v√©nement
  switch (event.type) {
    case 'checkout.session.completed': {
      console.log('‚úÖ Checkout session completed')
      console.log('Event data:', event.data.object)

      // Connexion √† la base de donn√©es
      await connectMongooseToDatabase()

      // R√©cup√©ration du joueur via userId dans les metadata
      const player = await Player.findOne({
        userId: event?.data?.object?.metadata?.userId
      })

      if (player !== null && player !== undefined) {
        // Calcul du montant pay√© (Stripe renvoie en centimes)
        const amountPaid = (event?.data?.object?.amount_total ?? 0) / 100

        // Recherche du package correspondant au prix pay√©
        const entry = Object.entries(pricingTable).find(
          ([_, pkg]) => pkg.price === amountPaid
        )

        if (entry !== undefined) {
          const koinsToAdd = Number(entry[0])

          console.log(`üí∞ Adding ${koinsToAdd} Koins to user ${String(player.userId)}`)

          // Mise √† jour du solde (Player.coins)
          const currentCoins = Number(player.coins ?? 0)
          player.coins = currentCoins + koinsToAdd
          player.markModified('coins')
          await player.save()

          console.log(`‚úÖ Wallet updated. New balance: ${String(player.coins)}`)
        } else {
          console.error('‚ö†Ô∏è No matching package found for amount:', amountPaid)
        }
      } else {
        console.error('‚ö†Ô∏è Player not found for user:', event?.data?.object?.metadata?.userId)
      }
      break
    }

    case 'payment_intent.succeeded': {
      console.log('‚úÖ Payment intent succeeded')
      console.log('Event data:', event.data.object)
      // TODO: G√©rer le flow Payment Element si n√©cessaire
      break
    }

    case 'payment_intent.payment_failed': {
      console.log('‚ùå Payment failed')
      console.log('Event data:', event.data.object)
      // TODO: G√©rer les √©checs de paiement (notification utilisateur, etc.)
      break
    }

    default:
      console.log(`‚ÑπÔ∏è Unhandled event type: ${event.type}`)
  }

  // Stripe attend toujours une r√©ponse 200
  return new Response('ok', { status: 200 })
}
